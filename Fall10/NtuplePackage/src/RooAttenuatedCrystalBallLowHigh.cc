/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooAttenuatedCrystalBallLowHigh.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(RooAttenuatedCrystalBallLowHigh) 

 RooAttenuatedCrystalBallLowHigh::RooAttenuatedCrystalBallLowHigh(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _mu,
                        RooAbsReal& _kT,
                        RooAbsReal& _mean,
                        RooAbsReal& _sigma,
                        RooAbsReal& _alpha,
                        RooAbsReal& _n,
                        RooAbsReal& _alpha2,
                        RooAbsReal& _n2) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   mu("mu","mu",this,_mu),
   kT("kT","kT",this,_kT),
   mean("mean","mean",this,_mean),
   sigma("sigma","sigma",this,_sigma),
   alpha("alpha","alpha",this,_alpha),
   n("n","n",this,_n),
   alpha2("alpha2","alpha2",this,_alpha2),
   n2("n2","n2",this,_n2)
 { 
 } 


 RooAttenuatedCrystalBallLowHigh::RooAttenuatedCrystalBallLowHigh(const RooAttenuatedCrystalBallLowHigh& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   mu("mu",this,other.mu),
   kT("kT",this,other.kT),
   mean("mean",this,other.mean),
   sigma("sigma",this,other.sigma),
   alpha("alpha",this,other.alpha),
   n("n",this,other.n),
   alpha2("alpha2",this,other.alpha2),
   n2("n2",this,other.n2)
 { 
 } 



 Double_t RooAttenuatedCrystalBallLowHigh::evaluate() const 
 { 
  double attenuation =  1. / ( exp( -1.*(x-mu)/ kT ) + 1.);
  
  if( (x-mean)/sigma > fabs(alpha) )  
    {
      double A = pow(n/fabs(alpha), n) * exp(-0.5 * alpha*alpha);
      double B = n/fabs(alpha) - fabs(alpha);
    
      return attenuation * A * pow(B + (x-mean)/sigma, -1.*n);
    }
  
  else if( (x-mean)/sigma < -1.*fabs(alpha2) )
    {
      double A = pow(n2/fabs(alpha2), n2) * exp(-0.5 * alpha2*alpha2);
      double B = n2/fabs(alpha2) - fabs(alpha2);
    
      return attenuation * A * pow(B - (x-mean)/sigma, -1.*n2);
    }
  
  else
    {
      return attenuation * exp(-1. * (x-mean)*(x-mean) / (2*sigma*sigma) );
    } 
  return 0. ;  
 } 
